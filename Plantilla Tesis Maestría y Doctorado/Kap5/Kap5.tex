\chapter{Componentes triconexas en un bigrafo $\DynD_{n}$.}

\section{Algoritmo para encontrar componentes triconexas de un bigrafo de tipo $\DynD_{n}$}

\begin{minted}[mathescape, linenos]{python}

class _LinkedListNode:

	def __init__(self, data=None):

		self.data = data
		self.prev = None
		self.next = None
		self.set_data(self.data)

	def set_data(self, data):
		self.data = data

	def get_data(self):
		return self.data

\end{minted}

\begin{minted}[mathescape, linenos]{python}

class _LinkedList:

	def __init__(self):

		self.head = None
		self.tail = None
		self.length = 0

	def remove(self, node):

		if node.prev is None and node.next is None:
			self.head = None
			self.tail = None
		elif node.prev is None:
			self.head = node.next
			node.next.prev = None
		elif node.next is None:
			node.prev.next = None
			self.tail = node.prev
		else:
			node.prev.next = node.next
			node.next.prev = node.prev
		self.length -= 1

	def set_head(self, h):

		self.head = h
		self.tail = h
		self.length = 1

	def append(self, node):

		if self.head is None:
			self.set_head(node)
		else:
			self.tail.next = node
			node.prev = self.tail
			self.tail = node
			self.length += 1

	def get_head(self):
		return self.head

	def get_length(self):
		return self.length

	def push_front(self, node):

		if self.head is None:
			self.set_head(node)
		else:
			self.head.prev = node
			node.next = self.head
			self.head = node
			self.length += 1

	def to_string(self):

		temp = self.head
		s = ""
		while temp:
			s += "  " + str(temp.get_data())
			temp = temp.next
		return s

	def concatenate(self, lst2):

		self.tail.next = lst2.head
		lst2.head.prev = self.tail
		self.tail = lst2.tail
		self.length += lst2.length
		lst2.head = None
		lst2.length = 0

\end{minted}

\begin{minted}[mathescape, linenos]{python}

class _Component:

	def __init__(self, edge_list, type_c):

		self.edge_list = _LinkedList()
		for e in edge_list:
			self.add_edge(e)
		self.component_type = type_c

	def add_edge(self, e):
		self.edge_list.append(_LinkedListNode(e))

	def finish_tric_or_poly(self, e):

		self.add_edge(e)
		if self.edge_list.get_length() > 3:
			self.component_type = 2
		else:
			self.component_type = 1

	def __str__(self):

		if self.component_type == 0:
			type_str = "Bond: "
		elif self.component_type == 1:
			type_str =  "Polygon: "
		else:
			type_str = "Triconnected: "
		return type_str + self.edge_list.to_string()

	def get_edge_list(self):

		e_list = []
		e_node = self.edge_list.get_head()
		while e_node:
			e_list.append(e_node.get_data())
			e_node = e_node.next
		return e_list

\end{minted}

\begin{minted}[mathescape, linenos]{python}

class _LinkedListNode:

	def __init__(self, data=None):

		self.data = data
		self.prev = None
		self.next = None
		self.set_data(self.data)

	def set_data(self, data):
		self.data = data

	def get_data(self):
		return self.data

\end{minted}

\begin{minted}[mathescape, linenos]{python}

class TriconnectivitySPQR:

	def __init__(self, G, check=True):

		self.n = G.order()
		self.m = G.size()
		self.graph_name = G.name()


		if self.n < 2:
			raise ValueError("Graph is not biconnected")
		elif self.n == 2 and self.m:

			self.comp_list_new = [G.edges()]
			self.comp_type = [0]
			self.__build_spqr_tree()
			return
		elif self.m < self.n -1:

			raise ValueError("Graph is not connected")
		elif self.m < self.n:

			raise ValueError("Graph is not biconnected")

		self.int_to_vertex = G.vertices()
		self.vertex_to_int = {u:i for i,u in enumerate(self.int_to_vertex)}
		self.int_to_original_edge_label = []
		self.graph_copy = Graph(self.n, multiedges=True)
		for i,(u, v, l) in enumerate(G.edge_iterator()):
			self.graph_copy.add_edge(self.vertex_to_int[u], self.vertex_to_int[v], i)
			self.int_to_original_edge_label.append(l)


		self.edge_status = {e: 0 for e in self.graph_copy.edge_iterator()}


		self.reverse_edges = set()

		self.dfs_number = [0 for i in range(self.n+1)]


		self.highpt = [_LinkedList() for i in range(self.n)]


		self.in_high = {e:None for e in self.graph_copy.edge_iterator()}


		self.old_to_new = [0 for i in range(self.n+1)]
		self.newnum = [0 for i in range(self.n)]
		self.node_at = [0 for i in range(self.n+1)]
		self.lowpt1 = [None for i in range(self.n)]
		self.lowpt2 = [None for i in range(self.n)]


		self.adj = [_LinkedList() for i in range(self.n)]


		self.in_adj = {}
		self.nd = [None for i in range(self.n)]


		self.parent = [None for i in range(self.n)]
		self.degree = [None for i in range(self.n)]
		self.tree_arc = [None for i in range(self.n)]
		self.vertex_at = [1 for i in range(self.n)]
		self.dfs_counter = 0
		self.components_list = []
		self.graph_copy_adjacency = [[] for i in range(self.n)]


		self.starts_path = {e:False for e in self.graph_copy.edge_iterator()}

		self.is_biconnected = True
		self.cut_vertex = None


		self.virtual_edge_num = 0

		self.virtual_edges = set()

		self.new_path = False


		self.e_stack = []
		self.t_stack_h = [None for i in range(2*self.m + 1)]
		self.t_stack_a = [None for i in range(2*self.m + 1)]
		self.t_stack_b = [None for i in range(2*self.m + 1)]
		self.t_stack_top = 0
		self.t_stack_a[self.t_stack_top] = -1


		self.comp_list_new = []
		self.comp_type = []

		self.spqr_tree = None

		self.type1 = []
		self.type2 = []

		for e in self.graph_copy.edge_iterator():
			self.graph_copy_adjacency[e[0]].append(e)
			self.graph_copy_adjacency[e[1]].append(e)

		self.dfs_counter = 0
		self.start_vertex = 0
		self.cut_vertex = self.__dfs1(self.start_vertex, check=check)

		if check:
			# If graph is disconnected
			if self.dfs_counter < self.n:
				raise ValueError("Graph is not connected")

			# If graph has a cut vertex
			if self.cut_vertex != None:
				raise ValueError("Graph has a cut vertex")


		for e in self.graph_copy.edge_iterator():
			up = (self.dfs_number[e[1]] - self.dfs_number[e[0]]) > 0
			if (up and self.edge_status[e]==2) or (not up and self.edge_status[e]==1):

				self.reverse_edges.add(e)

		self.__build_acceptable_adj_struct()
		self.__dfs2()

		self.__path_search(self.start_vertex)


		if self.e_stack:
			e = self.__estack_pop()
			c = _Component(self.e_stack, 0)
			c.finish_tric_or_poly(e)
			self.components_list.append(c)

		self.__print_split()
		self.__assemble_triconnected_components()

		self.__build_spqr_tree()

	def __tstack_push(self, h, a, b):

		self.t_stack_top += 1
		self.t_stack_h[self.t_stack_top] = h
		self.t_stack_a[self.t_stack_top] = a
		self.t_stack_b[self.t_stack_top] = b

	def __tstack_push_eos(self):

		self.t_stack_top += 1
		self.t_stack_a[self.t_stack_top] = -1

	def __tstack_not_eos(self):

		return self.t_stack_a[self.t_stack_top] != -1

	def __tstack_print(self):

		return self.t_stack_a, self.t_stack_b, self.t_stack_h

	def __estack_pop(self):

		return self.e_stack.pop()

	def __estack_print(self):

		return self.e_stack

	def __new_component(self, edges=[], type_c=0):

		c = _Component(edges, type_c)
		self.components_list.append(c)
		return c

	def __new_virtual_edge(self, u, v):

		e = (u, v, "newVEdge"+str(self.virtual_edge_num))
		self.virtual_edge_num += 1
		self.virtual_edges.add(e)
		return e

	def __high(self, v):

		head = self.highpt[v].get_head()
		if head is None:
			return 0
		else:
			return head.get_data()

	def __del_high(self, e):

		if e in self.in_high:
			it = self.in_high[e]
			if it:
				if e in self.reverse_edges:
					v = e[0]
				else:
					v = e[1]
				self.highpt[v].remove(it)

	def __bucket_sort(self, bucket, edge_list):

		if len(bucket) == 1:
			return

		# Create n bucket linked lists
		bucket_list = []
		for i in range(self.n):
			bucket_list.append(_LinkedList())

		# Get the head pointer of the edge list
		e_node = edge_list.head

		# Link the n buckets w.r.t bucketId
		while e_node:
			bucketId = bucket[e_node.get_data()]
			if bucket_list[bucketId].get_head():
				bucket_list[bucketId].tail.next = e_node
				bucket_list[bucketId].tail = bucket_list[bucketId].tail.next
			else:
				bucket_list[bucketId].set_head(e_node)
			e_node = e_node.next

		# Rearrange the `edge_list` Using bucket list
		new_tail = None
		for i in range(self.n):
			new_head = bucket_list[i].get_head()
			if new_head:
				if new_tail:
					new_tail.next = new_head
				else:
					edge_list.set_head(new_head)
				new_tail = bucket_list[i].tail

		edge_list.tail = new_tail
		new_tail.next = None

	def __sort_edges(self):

		# Create a linkedlist of edges
		edge_list = _LinkedList()
		for e in self.graph_copy.edges(sort=False):
			edge_list.append(_LinkedListNode(e))

		bucketMin = {} # Contains the lower index of edge end point
		bucketMax = {} # Contains the higher index of edge end point

		# In `graph_copy`, every edge `(u, v)` is such that `u < v`.
		# Hence, `bucketMin` of an edge `(u, v)` will be `u`
		# and `bucketMax` will be `v`.
		for e in self.graph_copy.edge_iterator():
			bucketMin[e] = e[0]
			bucketMax[e] = e[1]

		# Sort according to the endpoint with lower index
		self.__bucket_sort(bucketMin, edge_list)
		# Sort according to the endpoint with higher index
		self.__bucket_sort(bucketMax, edge_list)

		# Return the head pointer to the sorted edge list
		return edge_list.get_head()

	def __dfs1(self, v, u=None, check=True):

		first_son = None # For testing biconnectivity
		s1 = None # Storing the cut vertex, if there is one
		self.dfs_counter += 1
		self.dfs_number[v] = self.dfs_counter
		self.parent[v] = u
		self.degree[v] = self.graph_copy.degree(v)
		self.lowpt1[v] = self.lowpt2[v] = self.dfs_number[v]
		self.nd[v] = 1
		for e in self.graph_copy_adjacency[v]:
			if self.edge_status[e]:
				continue

			w = e[0] if e[0] != v else e[1] # Opposite vertex of edge e
			if self.dfs_number[w] == 0:
				self.edge_status[e] = 1 # tree edge
				if first_son is None:
					first_son = w
				self.tree_arc[w] = e
				s1 = self.__dfs1(w, v, check)

				if check:
					# Check for cut vertex.
					# The situation in which there is no path from w to an
					# ancestor of v : we have identified a cut vertex
					if (self.lowpt1[w] >= self.dfs_number[v]) and (w != first_son or u != None):
						s1 = v

				# Calculate the `lowpt1` and `lowpt2` values.
				# `lowpt1` is the smallest vertex (the vertex x with smallest
				# dfs_number[x]) that can be reached from v.
				# `lowpt2` is the next smallest vertex that can be reached from v.
				if self.lowpt1[w] < self.lowpt1[v]:
					self.lowpt2[v] = min(self.lowpt1[v], self.lowpt2[w])
					self.lowpt1[v] = self.lowpt1[w]

				elif self.lowpt1[w] == self.lowpt1[v]:
					self.lowpt2[v] = min(self.lowpt2[v], self.lowpt2[w])

				else:
					self.lowpt2[v] = min(self.lowpt2[v], self.lowpt1[w])

				self.nd[v] += self.nd[w]

			else:
				self.edge_status[e] = 2 # frond
				if self.dfs_number[w] < self.lowpt1[v]:
					self.lowpt2[v] = self.lowpt1[v]
					self.lowpt1[v] = self.dfs_number[w]
				elif self.dfs_number[w] > self.lowpt1[v]:
					self.lowpt2[v] = min(self.lowpt2[v], self.dfs_number[w])

		return s1 # s1 is None if graph does not have a cut vertex


	def __build_acceptable_adj_struct(self):

		max_size = 3*self.n + 2
		bucket = [[] for _ in range(max_size + 1)]

		for e in self.graph_copy.edge_iterator():
			edge_type = self.edge_status[e]

			# compute phi value
			# bucket sort adjacency list by phi values
			if e in self.reverse_edges:
				if edge_type == 1: # tree arc
					if self.lowpt2[e[0]] < self.dfs_number[e[1]]:
						phi = 3*self.lowpt1[e[0]]
					else:
						phi = 3*self.lowpt1[e[0]] + 2
				else: # tree frond
					phi = 3*self.dfs_number[e[0]]+1
			else:
				if edge_type == 1: # tree arc
					if self.lowpt2[e[1]] < self.dfs_number[e[0]]:
						phi = 3*self.lowpt1[e[1]]
					else:
						phi = 3*self.lowpt1[e[1]] + 2
				else: # tree frond
					phi = 3*self.dfs_number[e[1]]+1

			bucket[phi].append(e)

		# Populate `adj` and `in_adj` with the sorted edges
		for i in range(1, max_size + 1):
			for e in bucket[i]:
				node = _LinkedListNode(e)
				if e in self.reverse_edges:
					self.adj[e[1]].append(node)
					self.in_adj[e] = node
				else:
					self.adj[e[0]].append(node)
					self.in_adj[e] = node

	def __path_finder(self, v):

		self.newnum[v] = self.dfs_counter - self.nd[v] + 1
		e_node = self.adj[v].get_head()
		while e_node:
			e = e_node.get_data()
			e_node = e_node.next
			w = e[1] if e[0] == v else e[0] # opposite vertex of e
			if self.new_path:
				self.new_path = False
				self.starts_path[e] = True
			if self.edge_status[e] == 1: # tree arc
				self.__path_finder(w)
				self.dfs_counter -= 1
			else:
				# Identified a new frond that enters `w`. Add to `highpt[w]`.
				highpt_node = _LinkedListNode(self.newnum[v])
				self.highpt[w].append(highpt_node)
				self.in_high[e] = highpt_node
				self.new_path = True


	def __dfs2(self):

		self.in_high = {e:None for e in self.graph_copy.edge_iterator()}
		self.dfs_counter = self.n
		self.newnum = [0 for i in range(self.n)]
		self.starts_path = {e:False for e in self.graph_copy.edge_iterator()}

		self.new_path = True

		# We call the pathFinder function with the start vertex
		self.__path_finder(self.start_vertex)

		# Update `old_to_new` values with the calculated `newnum` values
		for v in self.graph_copy.vertex_iterator():
			self.old_to_new[self.dfs_number[v]] = self.newnum[v]

		# Update lowpt values according to `newnum` values.
		for v in self.graph_copy.vertex_iterator():
			self.node_at[self.newnum[v]] = v
			self.lowpt1[v] = self.old_to_new[self.lowpt1[v]]
			self.lowpt2[v] = self.old_to_new[self.lowpt2[v]]

	def __path_search(self, v):

		y = 0
		vnum = self.newnum[v]
		outv = self.adj[v].get_length()
		e_node = self.adj[v].get_head()
		while e_node:
			e = e_node.get_data()
			it = e_node

			if e in self.reverse_edges:
				w = e[0] # target
			else:
				w = e[1]
			wnum = self.newnum[w]
			if self.edge_status[e] == 1: # e is a tree arc
				if self.starts_path[e]: # if a new path starts at edge e
					y = 0
					# Pop all (h,a,b) from tstack where a > lowpt1[w]
					if self.t_stack_a[self.t_stack_top] > self.lowpt1[w]:
						while self.t_stack_a[self.t_stack_top] > self.lowpt1[w]:
							y = max(y, self.t_stack_h[self.t_stack_top])
							b = self.t_stack_b[self.t_stack_top]
							self.t_stack_top -= 1
						self.__tstack_push(y, self.lowpt1[w], b)

					else:
						self.__tstack_push(wnum + self.nd[w] - 1, self.lowpt1[w], vnum)
					self.__tstack_push_eos()

				self.__path_search(w)

				self.e_stack.append(self.tree_arc[w])
				temp_node = self.adj[w].get_head()
				temp = temp_node.get_data()
				if temp in self.reverse_edges:
					temp_target = temp[0]
				else:
					temp_target = temp[1]

				# Type-2 separation pair check
				# while v is not the start_vertex
				while vnum != 1 and ((self.t_stack_a[self.t_stack_top] == vnum) or
									 (self.degree[w] == 2 and self.newnum[temp_target] > wnum)):

					a = self.t_stack_a[self.t_stack_top]
					b = self.t_stack_b[self.t_stack_top]
					e_virt = None
					if a == vnum and self.parent[self.node_at[b]] == self.node_at[a]:
						self.t_stack_top -= 1

					else:
						e_ab = None
						if self.degree[w] == 2 and self.newnum[temp_target] > wnum:
							# found type-2 separation pair - (v, temp_target)
							self.type2.append((v+1, temp_target+1))
							e1 = self.__estack_pop()
							e2 = self.__estack_pop()
							self.adj[w].remove(self.in_adj[e2])

							if e2 in self.reverse_edges:
								x = e2[0] # target
							else:
								x = e2[1] # target

							e_virt = self.__new_virtual_edge(v, x)
							self.graph_copy.add_edge(e_virt)
							self.degree[v] -= 1
							self.degree[x] -= 1

							if e2 in self.reverse_edges:
								e2_source = e2[1] # target
							else:
								e2_source = e2[0]
							if e2_source != w:
								raise ValueError("Graph is not biconnected")

							comp = _Component([e1, e2, e_virt], 1)
							self.components_list.append(comp)
							comp = None

							if self.e_stack:
								e1 = self.e_stack[-1]
								if e1 in self.reverse_edges:
									if e1[1] == x and e1[0] == v:
										e_ab = self.__estack_pop()
										self.adj[x].remove(self.in_adj[e_ab])
										self.__del_high(e_ab)
								else:
									if e1[0] == x and e1[1] == v:
										e_ab = self.__estack_pop()
										self.adj[x].remove(self.in_adj[e_ab])
										self.__del_high(e_ab)

						else: # found type-2 separation pair - (self.node_at[a], self.node_at[b])
							self.type2.append((self.node_at[a]+1, self.node_at[b]+1))
							h = self.t_stack_h[self.t_stack_top]
							self.t_stack_top -= 1

							comp = _Component([],0)
							while True:
								xy = self.e_stack[-1]
								if xy in self.reverse_edges:
									x = xy[1]
									xy_target = xy[0]
								else:
									x = xy[0]
									xy_target = xy[1]
								if not (a <= self.newnum[x] <= h and a <= self.newnum[xy_target] <= h):
									break
								if (self.newnum[x] == a and self.newnum[xy_target] == b) or (self.newnum[xy_target] == a and self.newnum[x] == b):
									e_ab = self.__estack_pop()
									if e_ab in self.reverse_edges:
										e_ab_source = e_ab[1] # source
									else:
										e_ab_source = e_ab[0] # source
									self.adj[e_ab_source].remove(self.in_adj[e_ab])
									self.__del_high(e_ab)

								else:
									eh = self.__estack_pop()
									if eh in self.reverse_edges:
										eh_source = eh[1]
									else:
										eh_source = eh[0]
									if it != self.in_adj[eh]:
										self.adj[eh_source].remove(self.in_adj[eh])
										self.__del_high(eh)

									comp.add_edge(eh)
									self.degree[x] -= 1
									self.degree[xy_target] -= 1

							e_virt = self.__new_virtual_edge(self.node_at[a], self.node_at[b])
							self.graph_copy.add_edge(e_virt)
							comp.finish_tric_or_poly(e_virt)
							self.components_list.append(comp)
							comp = None
							x = self.node_at[b]

						if e_ab is not None:
							comp = _Component([e_ab, e_virt], type_c=0)
							e_virt = self.__new_virtual_edge(v, x)
							self.graph_copy.add_edge(e_virt)
							comp.add_edge(e_virt)
							self.degree[x] -= 1
							self.degree[v] -= 1
							self.components_list.append(comp)
							comp = None

						self.e_stack.append(e_virt)
						# Replace the edge `it` with `e_virt`
						it.set_data(e_virt)

						self.in_adj[e_virt] = it
						self.degree[x] += 1
						self.degree[v] += 1
						self.parent[x] = v
						self.tree_arc[x] = e_virt
						self.edge_status[e_virt] = 1
						w = x
						wnum = self.newnum[w]

					# update the values used in the while loop check
					temp_node = self.adj[w].get_head()
					temp = temp_node.get_data()
					if temp in self.reverse_edges:
						temp_target = temp[0]
					else:
						temp_target = temp[1]

				# start type-1 check
				if self.lowpt2[w] >= vnum and self.lowpt1[w] < vnum and (self.parent[v] != self.start_vertex or outv >= 2):
					# type-1 separation pair - (self.node_at[self.lowpt1[w]], v)
					self.type1.append((self.node_at[self.lowpt1[w]]+1, v+1))
					# Create a new component and add edges to it
					comp = _Component([], 0)
					if not self.e_stack:
						raise ValueError("stack is empty")
					while self.e_stack:
						xy = self.e_stack[-1]
						if xy in self.reverse_edges:
							xx = self.newnum[xy[1]] #source
							y = self.newnum[xy[0]] #target
						else:
							xx = self.newnum[xy[0]] #source
							y = self.newnum[xy[1]] #target

						if not ((wnum <= xx and  xx < wnum + self.nd[w]) or
								(wnum <= y and y < wnum + self.nd[w])):
							break

						comp.add_edge(self.__estack_pop())
						self.__del_high(xy)
						self.degree[self.node_at[xx]] -= 1
						self.degree[self.node_at[y]] -= 1

					e_virt = self.__new_virtual_edge(v, self.node_at[self.lowpt1[w]])
					self.graph_copy.add_edge(e_virt) # Add virtual edge to graph
					comp.finish_tric_or_poly(e_virt) # Add virtual edge to component
					self.components_list.append(comp)
					comp = None

					if (xx == vnum and y == self.lowpt1[w]) or (y == vnum and xx == self.lowpt1[w]):
						comp_bond = _Component([], type_c=0) # new triple bond
						eh = self.__estack_pop()
						if self.in_adj[eh] != it:
							if eh in self.reverse_edges:
								self.adj[eh[1]].remove(self.in_adj[eh])
							else:
								self.adj[eh[0]].remove(self.in_adj[eh])

						comp_bond.add_edge(eh)
						comp_bond.add_edge(e_virt)
						e_virt = self.__new_virtual_edge(v, self.node_at[self.lowpt1[w]])
						self.graph_copy.add_edge(e_virt)
						comp_bond.add_edge(e_virt)
						if eh in self.in_high:
							self.in_high[e_virt] = self.in_high[eh]
						self.degree[v] -= 1
						self.degree[self.node_at[self.lowpt1[w]]] -= 1
						self.components_list.append(comp_bond)
						comp_bond = None

					if self.node_at[self.lowpt1[w]] != self.parent[v]:
						self.e_stack.append(e_virt)

						# replace edge `it` with `e_virt`
						it.set_data(e_virt)

						self.in_adj[e_virt] = it
						if not e_virt in self.in_high and self.__high(self.node_at[self.lowpt1[w]]) < vnum:
							vnum_node = _LinkedListNode(vnum)
							self.highpt[self.node_at[self.lowpt1[w]]].push_front(vnum_node)
							self.in_high[e_virt] = vnum_node

						self.degree[v] += 1
						self.degree[self.node_at[self.lowpt1[w]]] += 1

					else:
						self.adj[v].remove(it)
						comp_bond = _Component([e_virt], type_c=0)
						e_virt = self.__new_virtual_edge(self.node_at[self.lowpt1[w]], v)
						self.graph_copy.add_edge(e_virt)
						comp_bond.add_edge(e_virt)

						eh = self.tree_arc[v];
						comp_bond.add_edge(eh)
						self.components_list.append(comp_bond)
						comp_bond = None

						self.tree_arc[v] = e_virt
						self.edge_status[e_virt] = 1
						if eh in self.in_adj:
							self.in_adj[e_virt] = self.in_adj[eh]
						e_virt_node = _LinkedListNode(e_virt)
						self.in_adj[eh] = e_virt_node
					# end type-1 search

				# if an path starts at edge e, empty the tstack.
				if self.starts_path[e]:
					while self.__tstack_not_eos():
						self.t_stack_top -= 1
					self.t_stack_top -= 1

				while self.__tstack_not_eos() and self.t_stack_b[self.t_stack_top] != vnum and self.__high(v) > self.t_stack_h[self.t_stack_top]:
					self.t_stack_top -= 1

				outv -= 1
			else: # e is a frond
				if self.starts_path[e]:
					y = 0
					# pop all (h,a,b) from tstack where a > w
					if self.t_stack_a[self.t_stack_top] > wnum:
						while self.t_stack_a[self.t_stack_top] > wnum:
							y = max(y, self.t_stack_h[self.t_stack_top])
							b = self.t_stack_b[self.t_stack_top]
							self.t_stack_top -= 1
						self.__tstack_push(y, wnum, b)

					else:
						self.__tstack_push(vnum, wnum, vnum)
				self.e_stack.append(e) # add (v,w) to ESTACK
			# Go to next edge in adjacency list
			e_node = e_node.next

	def __print_split(self):
		self.comp_list_new1 = []
		self.comp_type1 = []
		for comp in self.components_list:
			if comp.edge_list.get_length() > 0:
				e_list = comp.get_edge_list()
				e_list_new = []
				# For each edge, get the original source, target and label
				for u,v,l in e_list:
					source = self.int_to_vertex[u]
					target = self.int_to_vertex[v]
					if isinstance(l, str):
						label = l
					else:
						label = self.int_to_original_edge_label[l]
					e_list_new.append((source, target, label))
				self.comp_list_new1.append(e_list_new)
		return self.comp_list_new1

	def __assemble_triconnected_components(self):

		comp1 = {} # The index of first component that an edge belongs to
		comp2 = {} # The index of second component that an edge belongs to
		item1 = {} # Pointer to the edge node in component1
		item2 = {} # Pointer to the edge node in component2
		num_components = len(self.components_list)
		visited = [False for i in range(num_components)]

		# For each edge, we populate the comp1, comp2, item1 and item2 values
		for i in range(num_components): # for each component
			e_node = self.components_list[i].edge_list.get_head()
			while e_node: # for each edge
				e = e_node.get_data()
				if e not in item1:
					comp1[e] = i
					item1[e] = e_node
				else:
					comp2[e] = i
					item2[e] = e_node

				e_node = e_node.next

		# For each edge in a component, if the edge is a virtual edge, merge
		# the two components the edge belongs to
		for i in range(num_components):
			c1 = self.components_list[i]
			c1_type = c1.component_type
			l1 = c1.edge_list
			visited[i] = True

			if l1.get_length() == 0:
				continue

			if c1_type == 0 or c1_type == 1:
				e_node = self.components_list[i].edge_list.get_head()
				# Iterate through each edge in the component
				while e_node:
					e = e_node.get_data()
					e_node_next = e_node.next
					# The label of a virtual edge is a string
					if not isinstance(e[2], str):
						e_node = e_node_next
						continue

					j = comp1[e]
					if visited[j]:
						j = comp2[e]
						if visited[j]:
							e_node = e_node_next
							continue
						e_node2 = item2[e]
					else:
						e_node2 = item1[e]

					c2 = self.components_list[j]

					# If the two components are not the same type, do not merge
					if (c1_type != c2.component_type):
						e_node = e_node_next # Go to next edge
						continue

					visited[j] = True
					l2 = c2.edge_list

					# Remove the corresponding virtual edges in both the components
					# and merge the components
					l2.remove(e_node2)
					l1.concatenate(l2)

					# if `e_node_next` was empty, after merging two components,
					# more edges are added to the component.
					if not e_node_next:
						e_node_next = e_node.next # Go to next edge

					l1.remove(e_node)

					e_node = e_node_next

		# Convert connected components into original graph vertices and edges
		self.comp_list_new = []
		self.comp_type = []
		for comp in self.components_list:
			if comp.edge_list.get_length() > 0:
				e_list = comp.get_edge_list()
				e_list_new = []
				# For each edge, get the original source, target and label
				for u,v,l in e_list:
					source = self.int_to_vertex[u]
					target = self.int_to_vertex[v]
					if isinstance(l, str):
						label = l
					else:
						label = self.int_to_original_edge_label[l]
					e_list_new.append((source, target, label))
				# Add the component data to `comp_list_new` and `comp_type`
				self.comp_type.append(comp.component_type)
				self.comp_list_new.append(e_list_new)
	#print(self.comp_list_new)

	def __build_spqr_tree(self):

		# Types of components 0: "P", 1: "S", 2: "R"
		component_type = ["P", "S", "R"]

		self.spqr_tree = Graph(multiedges=False, name='SPQR-tree of {}'.format(self.graph_name))

		if len(self.comp_list_new) == 1 and self.comp_type[0] == 0:
			self.spqr_tree.add_vertex(('Q' if len(self.comp_list_new[0]) == 1 else 'P',
									   Graph(self.comp_list_new[0], immutable=True, multiedges=True)))
			return

		int_to_vertex = []
		partner_nodes = {}

		for i in range(len(self.comp_list_new)):
			# Create a new tree vertex
			u = (component_type[self.comp_type[i]],
				 Graph(self.comp_list_new[i], immutable=True, multiedges=True))
			self.spqr_tree.add_vertex(u)
			int_to_vertex.append(u)

			# Add an edge to each node containing the same virtual edge
			for e in self.comp_list_new[i]:
				if e in self.virtual_edges:
					if e in partner_nodes:
						for j in partner_nodes[e]:
							self.spqr_tree.add_edge(int_to_vertex[i], int_to_vertex[j])
						partner_nodes[e].append(i)
					else:
						partner_nodes[e] = [i]

\end{minted}
